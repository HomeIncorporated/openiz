-- OPEN IZ DATABASE CORE
-- COPYRIGHT (c) 2015, OPEN IZ
-- PORTIONS COPYRIGHT (C) 2015, FYFE SOFTWARE INC.
-- LICENSED UNDER THE APACHE 2.0 LICENSE

USE openiz;

/*
 PHONETIC ALGORITHM TABLE IS USED TO STORE A MASTER LIST OF PHONETIC ALGORITHMS
 REGISTERED WITH THE OPENIZ BACKBONE. THESE CLASSES IMPLEMENT THE IPHONETICALGORITHM
 INTERFACE AND ARE USED FOR CALCULATING THE PHONETIC CODES FOUND IN OTHER TABLES
*/
CREATE TABLE PhoneticAlgorithm
(
	PhoneticAlgorithmId NUMERIC(2) IDENTITY NOT NULL, -- THE ID FOR THE ALGORITHM
	Name NVARCHAR(32) NOT NULL, -- THE NAME OF THE ALGORITHM
	HandlerClass NVARCHAR(MAX) NOT NULL, -- THE HANDLER CLASS WHICH GENERATES THE CODE
	CONSTRAINT PK_PhoneticAlgorithm PRIMARY KEY (PhoneticAlgorithmId)
);

/*
 SECTION: SECURITY TABLES
*/

/*
 SECURITY USER IS PRIMARILY USED BY THE SECURITY SUBSYSTEM AND IS OFTEN LINKED TO A PERSON IN THE 
 CLINICAL DATA CONTEXT VIA THE USERENTITY RELATIONSHIP TABLE. THIS TABLE'S PRIMARY ROLE IS THE 
 STORAGE OF USER ACCOUNT INFORMATION
*/
CREATE TABLE SecurityUser
(
	UserId UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID(), -- THE UNIQUE IDENTIFIER FOR THE USER
	UserName NVARCHAR(128) NOT NULL, -- THE NAME OF THE USER
	Email NVARCHAR(250) NOT NULL UNIQUE, -- THE PRIMARY EMAIL ADDRESS OF THE USER
	EmailConfirmed BIT NOT NULL DEFAULT 0, -- TRUE IF EMAIL HAS BEEN CONFIRMED
	PhoneNumber NVARCHAR(128), -- THE PHONE NUMBER OF THE USER
	PhoneNumberConfirmed BIT NOT NULL DEFAULT 0, -- IF PHONE NUMBER HAS BEEN CONFIRMED
	TwoFactorEnabled BIT NOT NULL DEFAULT 0, -- TRUE IF TFA (PHONE or EMAIL CONFIRM) IS ENABLED
	LockoutEnabled BIT NOT NULL DEFAULT 0, -- TRUE IF THE ACCOUNT IS LOCKED OUT
	UserPassword NVARCHAR(128) NOT NULL, -- THE PASSWORD OF THE USER
	SecurityStamp NVARCHAR(128) NOT NULL, -- THE SALT FOR USER PASSWORD
	FailedLoginAttempts INT NOT NULL DEFAULT 0, -- THE NUMBER OF FAILED LOGIN ATTEMPTS
	LastSuccessfulLogin DATETIMEOFFSET, -- THE LAST TIME WHEN THE USER SUCCESSFULLLY LOGGED IN
	CreationTime DATETIMEOFFSET NOT NULL DEFAULT CURRENT_TIMESTAMP, -- THE TIME THE USER WAS CREATED
	CreatedBy UNIQUEIDENTIFIER, -- THE USER THAT CREATED THE USER
	ObsoletionTime DATETIMEOFFSET, -- WHEN PRESENT, INDICATES THE DATE THE USER ACCOUNT IS NOT LONGER ACTIVE
	ObsoletedBy UNIQUEIDENTIFIER, -- THE USER WHO OBSOLETED THIS RECORD
	UpdatedTime DATETIMEOFFSET, -- THE TIME THE RECORD WAS UPDATED
	UpdatedBy UNIQUEIDENTIFIER, -- THE PERSON WHO UPDATED THE USER RECORD
	CONSTRAINT PK_SecurityUser PRIMARY KEY (UserId),
	CONSTRAINT FK_SecurityUserObsoletedBy FOREIGN KEY (ObsoletedBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT CK_SecurityUserObsoletedBy CHECK(ObsoletedBy IS NOT NULL AND ObsoletionTime IS NOT NULL OR ObsoletedBy IS NULL AND ObsoletionTime IS NULL),
	CONSTRAINT FK_SecurityUserCreatedBy FOREIGN KEY (CreatedBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT FK_SecurityUserUpdatedBy FOREIGN KEY (UpdatedBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT CK_SecurityUserUpdatedBy CHECK(UpdatedBy IS NOT NULL AND UpdatedTime IS NOT NULL OR UpdatedBy IS NULL AND UpdatedTime IS NULL)
);

/*
 THE FOLLOWING INDEXING PROVIDES LOOKUP BY USERNAME AND USERNAME/PASSWORD COMBINATION
*/
CREATE UNIQUE INDEX IX_SecurityUserUserName ON SecurityUser(UserName);
CREATE INDEX IX_SecurityUserUserNamePassword ON SecurityUser(UserName, UserPassword);

/*
 THE FOLLOWING TABLE IS USED BY THE CLAIMS SYSTEM TO STORE THE GRANTED
 CLAIMS FOR EACH USER
*/
CREATE TABLE SecurityUserClaim
(
	ClaimId UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID(), -- CLAIM ID
	UserId UNIQUEIDENTIFIER NOT NULL, -- THE USER TO WHICH THE CLAIM BELONGS
	ClaimType NVARCHAR(128), -- THE TYPE OF CLAIM
	ClaimValue NVARCHAR(128), -- THE VALUE OF THE CLAIM
	CONSTRAINT PK_SecurityUserClaim PRIMARY KEY (ClaimId),
	CONSTRAINT FK_SecurityUserClaimUserId FOREIGN KEY (UserId) REFERENCES SecurityUser(UserId)
);

/*
 INDEX LOOKUP CLAIM BY USER
*/
CREATE INDEX IX_SecurityUserClaimUser ON SecurityUserClaim(UserId);

/*
 THIS TABLE IS USED TO STORE THE EXTERNAL LOGIN PROVIDERS AND KEYS FOR 
 EACH USER WHO HAS ASSOCIATED AN EXTERNAL LOGIN PROVIDER. THESE CAN BE 
 OAUTH SERVICES (SUCH AS A CENTRAL PROVIDER) OR PUBLIC SERVICES LIKE GMAIL, 
 LIVEID, ETC.
*/
CREATE TABLE SecurityUserLogins
(
	LoginProvider NVARCHAR(128) NOT NULL, -- THE LOGIN PROVIDER (GMAIL, LIVE, ETC)
	ProviderKey NVARCHAR(128) NOT NULL, -- THE PROVIDER KEY
	UserId UNIQUEIDENTIFIER NOT NULL, -- THE USER
	CONSTRAINT PK_SecurityUserLogins PRIMARY KEY (LoginProvider, ProviderKey, UserId),
	CONSTRAINT FK_SecurityUserLoginsUserId FOREIGN KEY (UserId) REFERENCES SecurityUser(UserId),
);

/*
 SECURITY ROLES ARE USED TO GROUP POLICIES AND ACTIONS AS WELL AS ACCESS TO PARTICULAR 
 AREAS OF POINT OF SERVICE APPLICATIONS BASED ON POLICY. 
*/
CREATE TABLE SecurityRole
(
	RoleId UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID(), -- THE ROLE IDENTIFIER
	Name NVARCHAR(50) NOT NULL, -- THE NAME OF THE ROLE
	CreationTime DATETIMEOFFSET NOT NULL DEFAULT CURRENT_TIMESTAMP, -- THE TIME THE ROLE WAS CREATED
	CreatedBy UNIQUEIDENTIFIER NOT NULL, -- THE USER WHO CREATED THE ROLE
	ObsoletionTime DATETIMEOFFSET, -- THE TIME THE ROLE WAS OBSOLETED
	ObsoletedBy UNIQUEIDENTIFIER, -- THE USER WHO OBSOLETED THE RECORD
	CONSTRAINT PK_SecurityRole PRIMARY KEY (RoleId),
	CONSTRAINT FK_SecurityRoleCreatedBy FOREIGN KEY (CreatedBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT FK_SecurityRoleObsoletedBy FOREIGN KEY (ObsoletedBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT CK_SecurityRoleObsoletedBy CHECK(ObsoletedBy IS NOT NULL AND ObsoletionTime IS NOT NULL OR ObsoletedBy IS NULL AND ObsoletionTime IS NULL)
);

/*
 SECURITY USER <> ROLE ASSOCIATIVE ENTITY
*/
CREATE TABLE SecurityUserRole
(
	UserId UNIQUEIDENTIFIER NOT NULL, -- THE USER TO WHICH THE ASSOCIATION BELONGS
	RoleId UNIQUEIDENTIFIER NOT NULL, -- THE ROLE TO WHICH THE USER BELONGS
	CONSTRAINT PK_SecurityUserRole PRIMARY KEY (UserId, RoleId),
	CONSTRAINT FK_SecurityUserRoleUserId FOREIGN KEY (UserId) REFERENCES SecurityUser(UserId),
	CONSTRAINT FK_SecurityUserRoleRoleId FOREIGN KEY (RoleId) REFERENCES SecurityRole(RoleId)
);

-- INDEX : LOOKUP SECURITY ROLE ASSOCIATIONS BY USER ID
CREATE INDEX IX_SecurityUserRoleUserId ON SecurityUserRole(UserId);

/*
 THE POLICY TABLE IS USED TO DEFINE A SERIES OF POLICIES WHICH MUST BE ADHERED TO
 WHEN ACCESSING, STORING OR RETRIEVING CLINICAL DATA TO/FROM THE OPENIZ BACKBONE.
 EXAMPLES OF A POLICY CAN INCLUDE:

	- ALLOW LOGIN FOR A USER ON A DEVICE
	- ALLOW A GROUP OF USERS TO ACCESS AN ACT
	- RESTRICTED ACCESS TO AN ACT
 
 POLICIES WHICH ARE PUBLIC ARE THOSE POLICIES WHICH ARE ATTACHED TO ANY CDA/FHIR/XDS MESSAGE
 ORIGINATING FROM THE OPEN IZ CORE AND ARE NOT CONTROLLED UNDER THE LOCAL AUTHORITY OF THE 
 ADMINISTRATIVE STAFF. 

 POLICIES ARE ENFORCED TWO WAYS, FIRST THE DATA LAYER WILL CHECK THE SecurityRolePolicy AND
 SecurityDevicePolicy TABLES TO ENSURE THAT NONE OF THE ROLES OR THE CURRENT DEVICE HAS AN 
 IsDeny OF TRUE, IF TRUE IS FOUND ON IsDeny AND CanElevate IS ENABLED FOR THE POLICY THEN 
 THE USER MAY BE GIVEN AN OPTION TO ELEVATE (BREAK THE GLASS). 

 THE SECOND ROUND TYPE OF POLICY CHECK RELIES ON THE PRESENCE OF A POLICY HANDLER WHICH, IF
 ENABLED, WILL BE EXECUTED ON PERSISTENCE AND DE-PERSISTENCE. 
 
 FINALLY SOME OPENIZ CODE MAY EXPLICITLY LOOK FOR POLICIES TO BE ENFORCED. FOR EXAMPLE, ALLOW
 LOGIN POLICY HAS A PARTICULAR OID WHICH THE OPENIZ LOGIN HANDLER WILL CHECK FOR THE USER AND
 DEVICE.
*/ 
CREATE TABLE Policy
(
	PolicyId UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID(), -- THE UNIQUE IDENTIFIER FOR THE POLICY
	PolicyOid NVARCHAR(128) NOT NULL, -- THE OID FOR THE POLICY
	Name NVARCHAR(64) NOT NULL, -- THE NAME OF THE POLICY
	HandlerClass NVARCHAR(256), -- THE HANDLER WHICH IS A PIECE OF .NET CODE WHICH ENFORCES THE POLICY
	IsPublic BIT NOT NULL DEFAULT 0,
	CanElevate BIT NOT NULL DEFAULT 0,
	CONSTRAINT PK_Policy PRIMARY KEY (PolicyId)
);

CREATE UNIQUE INDEX IX_PolicyOid ON Policy(PolicyOid);

/*
 ASSOCIATIVE ENTITY TABLE BETWEEN SecurityRole AND Policy TABLES.
*/
CREATE TABLE SecurityRolePolicy 
(
	RoleId UNIQUEIDENTIFIER NOT NULL, -- THE ROLE TO WHICH THE POLICY APPLIES
	PolicyId UNIQUEIDENTIFIER NOT NULL, -- THE POLICY TO WHICH THE ASSOCIATION APPLIES
	IsDeny BIT NOT NULL DEFAULT 0, -- WHEN TRUE, INDICATES THAT THE PRESENCE OF A POLICY ON AN ACT IS A DENY FOR THE ROLE
	CONSTRAINT PK_SecurityRolePolicy PRIMARY KEY (RoleId, PolicyId),
	CONSTRAINT FK_SecurityRolePolicyRoleId FOREIGN KEY (RoleId) REFERENCES SecurityRole(RoleId),
	CONSTRAINT FK_SecurityRolePolicyPolicyId FOREIGN KEY (PolicyId) REFERENCES Policy(PolicyId)
);

CREATE INDEX IX_SecurityPolicyRoleId ON SecurityRolePolicy(RoleId);

/*
 A SECURITY DEVICE TABLE IS USED TO TRACK THE SECRETS FOR DEVICES DEPLOYED IN THE FIELD
 AND ALLOWS THE OPEN IZ BACKBONE TO DENY AND/OR ALERT THE USER OF NEW SIGN INS FROM
 A NEW DEVICE.

 THE SecurityDevice TABLE IS KEYED OFF THE DEVICE SECRET WHICH MAY BE A BASIC AUTH
 HEADER, A VALUE IN THE IUA HEADER (JWT TOKEN) OR TLS CERTIFICATE USED FOR COMMUNICATION
*/
CREATE TABLE SecurityDevice
(
	DeviceId UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID(), -- THE DEVICE IDENTIFIER
	DeviceSecret NVARCHAR(64) NOT NULL, -- THE SECRET USED TO AUTHENTICATE THE DEVICE (EX: X509 THUMBPRINT)
	CreationTime DATETIMEOFFSET NOT NULL DEFAULT CURRENT_TIMESTAMP, -- THE TIME THE DEVICE RECORD WAS CREATED
	CreatedBy UNIQUEIDENTIFIER NOT NULL, -- THE USER THAT CREATED THE DEVICE
	ObsoletionTime DATETIMEOFFSET, -- THE TIME THE DEVICE RECORD WAS OBSOLETED
	ObsoletedBy UNIQUEIDENTIFIER, -- THE PERSON WHO OBSOLETED THE DEVICE
	ReplacesDeviceId UNIQUEIDENTIFIER, -- A POINTER TO A DEVICE THAT THIS DEVICE RECORD REPLACES
	CONSTRAINT PK_SecurityDevice PRIMARY KEY (DeviceId),
	CONSTRAINT FK_SecurityDeviceCreatedBy FOREIGN KEY (CreatedBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT FK_SecuirtyDeviceObsoletedBy FOREIGN KEY (ObsoletedBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT CK_SecurityDeviceObsoletedBy CHECK(ObsoletedBy IS NOT NULL AND ObsoletionTime IS NOT NULL OR ObsoletedBy IS NULL AND ObsoletionTime IS NULL)
);

CREATE INDEX IX_SecurityDeviceSecret ON SecurityDevice(DeviceSecret);

/*
 ASSOCIATIVE ENTITY TABLE BETWEEN SECURITY DEVICE AND POLICY
*/
CREATE TABLE SecurityDevicePolicy
(
	DeviceId UNIQUEIDENTIFIER NOT NULL, -- THE DEVICE TO WHICH THE POLICY ASSOCIATION APPLIES 
	PolicyId UNIQUEIDENTIFIER NOT NULL, -- THE POLICY IDENTIFIER TO WHICH THE POLICY ASSOCIATION APPLIES
	IsDeny BIT NOT NULL DEFAULT 0, -- WHEN TRUE INDICATES THE ACTS WITH POLICY APPLIED IS A DENY
	CONSTRAINT PK_SecurityDevicePolicy PRIMARY KEY (DeviceId, PolicyId),
	CONSTRAINT FK_SecurityDevicePolicyDeviceId FOREIGN KEY (DeviceId) REFERENCES SecurityDevice(DeviceId),
	CONSTRAINT FK_SecurityDevicePolicyPolicyId FOREIGN KEY (PolicyId) REFERENCES Policy(PolicyId)
);

/* 
 END SECTION: SECURITY TABLES
 */

/*
 SECTION: CONCEPT TABLES
*/

/*
 THE CONCEPT TABLE IS THE MASTER TABLE WHICH TRACKS INTERNAL CONCEPTS USED BY THE 
 OPENIZ SYSTEM. CONCEPTS ARE STORED HERE LOCALLY AS A CANONICAL CONCEPT IN THE
 OPENIZ CONCEPT DICTIONARY

 CONCEPTS MARKED AS IsSystemConcept ARE READONLY AND CANNOT BE EDITED BY USER 
 INTERFACE.
*/
CREATE TABLE Concept
(
	ConceptId NUMERIC(15) IDENTITY NOT NULL, -- THE UNIQUE IDENTIFIER FOR THE CONCEPT
	IsSystemConcept BIT NOT NULL DEFAULT 0, -- WHEN TRUE, INDICATES THE CONCEPT IS A SYSTEM CONCEPT
	CONSTRAINT PK_Concept PRIMARY KEY (ConceptId)
);

/*
 THE CONCEPT CLASSIFICATION TABLE IS USED TO CLASSIFY THE CONCEPTS REPRESENTED
 IN THE DICTIONARY. CONCEPT CLASSIFICATIONS ARE USED BY VALIDATION ROUTINES
 TO ENSURE THAT A CONCEPT IS APPROPRIATELY USED
*/
CREATE TABLE ConceptClass
(
	ConceptClassId NUMERIC(2) IDENTITY NOT NULL, -- THE CONCEPT CLASSIFICATION ID
	Name NVARCHAR(50) NOT NULL, -- THE NAME OF THE CONCEPT CLASSIFICATION
	Mnemonic NVARCHAR(16) NOT NULL, -- THE MNEMONIC USED BY THE SYSTEM TO LOCATE CONCEPTS
	CONSTRAINT PK_ConceptClass PRIMARY KEY (ConceptClassId)
);

-- INDEX: LOOKUP CONCEPT CLASS BY MNEMONIC
CREATE UNIQUE INDEX IX_ConceptClassMnemonic ON ConceptClass(Mnemonic);

-- DEFAULT CLASS CODES
INSERT INTO ConceptClass (Name, Mnemonic) VALUES ('Classification', 'ClassCode');
INSERT INTO ConceptClass (Name, Mnemonic) VALUES ('Status', 'Status');
INSERT INTO ConceptClass (Name, Mnemonic) VALUES ('Mood', 'Mood');
INSERT INTO ConceptClass (Name, Mnemonic) VALUES ('Relationship Type', 'Relationship');
INSERT INTO ConceptClass (Name, Mnemonic) VALUES ('Route', 'Route');
INSERT INTO ConceptClass (Name, Mnemonic) VALUES ('Unit of Measure', 'UnitOfMeasure');
INSERT INTO ConceptClass (Name, Mnemonic) VALUES ('Diagnosis', 'Diagnosis');
INSERT INTO ConceptClass (Name, Mnemonic) VALUES ('Findings', 'Finding');
INSERT INTO ConceptClass (Name, Mnemonic) VALUES ('Problem', 'Problem');
INSERT INTO ConceptClass (Name, Mnemonic) VALUES ('Drug or other Material', 'Material');
INSERT INTO ConceptClass (Name, Mnemonic) VALUES ('Other Classification', 'Other');
INSERT INTO ConceptClass (Name, Mnemonic) VALUES ('Stock control codes', 'Stock');

/*
 THE CONCEPT SET TABLE IS USED TO DEFINE A SERIES OF CONCEPTS WHICH CAN BE SELECTED FOR A PARTICULAR PURPOSE
 THIS IS NOT LIKE A CONCEPT WITH MEMBERS (EXMAPLE ICD10 Z30 VS Z30.1), RATHER THIS IS A VALUE SET OF RESTRICTED 
 DOMAIN OF CONCEPTS
*/
CREATE TABLE ConceptSet
(
	ConceptSetId NUMERIC(10) IDENTITY NOT NULL, -- THE CONCEPT SET UNIQUE ID
	Name NVARCHAR(64) NOT NULL, -- THE NAME OF THE CONCEPT SET
	Mnemonic NVARCHAR(16) NOT NULL, -- THE SYSTEM MNEMONIC OF THE CONCEPT SET
	Oid NVARCHAR(64) NOT NULL, -- THE OID (EXTERNAL) OF THE CONCEPT SET
	Url NVARCHAR(256) NOT NULL, -- THE URL OF THE CONCEPT SET
	CreationTime DATETIMEOFFSET NOT NULL DEFAULT CURRENT_TIMESTAMP, -- THE CREATIONTIME OF THE CODE SYSTEM
	CreatedBy UNIQUEIDENTIFIER NOT NULL, -- THE USER WHICH CREATED THIS CODE SYSTEM
	ObsoletionTime DATETIMEOFFSET, -- WHEN PRESENT THE TIME THE RECORD WAS OBSOLETED
	ObsoletedBy UNIQUEIDENTIFIER, -- WHEN PRESENT INDICATES THE PERSON WHO OBSOLETED RECORD
	ObsoletionReason NVARCHAR(MAX) , -- WHEN PRESENT INDICATES WHY THE RECORD WAS OBSOLETED
	CONSTRAINT PK_ConceptSet PRIMARY KEY (ConceptSetId),
	CONSTRAINT FK_ConceptSetCreatedBy FOREIGN KEY (CreatedBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT FK_ConceptSetObsoletedBy FOREIGN KEY (ObsoletedBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT CK_ConceptSetObsoletedBy CHECK(ObsoletedBy IS NOT NULL AND ObsoletionTime IS NOT NULL OR ObsoletedBy IS NULL AND ObsoletionTime IS NULL),
	CONSTRAINT CK_ConceptSetObsoletionReason CHECK(ObsoletionReason IS NOT NULL AND ObsoletionTime IS NOT NULL OR ObsoletionTime IS NULL AND ObsoletionReason IS NULL)
);

CREATE UNIQUE INDEX IX_ConceptSetOid ON ConceptSet(Oid);
CREATE UNIQUE INDEX IX_ConceptSetUrl ON ConceptSet(Url);
CREATE UNIQUE INDEX IX_ConceptSetMnemonic ON ConceptSet(Mnemonic);

/*
 REPRESENTS A SINGLE CONCEPT WITHIN THE CONCEPT SET
*/
CREATE TABLE ConceptSetMember
(
	ConceptSetId NUMERIC(10) NOT NULL, -- THE CONCEPT SET
	ConceptId NUMERIC(15) NOT NULL, -- THE CONCEPT WHICH BELONGS TO THE SET
	CONSTRAINT PK_ConceptSetMember PRIMARY KEY (ConceptSetId, ConceptId),
	CONSTRAINT FK_ConceptSetMemberConceptSetId FOREIGN KEY (ConceptSetId) REFERENCES ConceptSet(ConceptSetId),
	CONSTRAINT FK_ConceptSetMemberConceptId FOREIGN KEY (ConceptId) REFERENCES Concept(ConceptId)
);

/*
 CONCEPTS ARE VERSIONED, MEANING THAT EACH EDIT TO A CONCEPT'S CORE ATTRIBUTES
 RESULTS IN A NEW VERSION OF THE CONCEPT. THIS IS DONE FOR A MEDICAL LEGAL REASON
 SUCH THAT THE EXACT ATTRIBUTES OF A CONCEPT SELECTED BY A CLINICIAN CAN BE STORED
 IN ACTS AND ENTITIES FOR LATER RETRIEVAL. 

 CONCEPT VERSIONING CAN MAKE THE DATABASE QUITE LARGE, AND IT IS RECOMMENDED THAT
 PARTITIONING AND/OR PRUNING VIA THE usp_PruneConceptVersions BE PERFORMED REGULARLY
*/
CREATE TABLE ConceptVersion
(
	ConceptVersionId NUMERIC(15) IDENTITY NOT NULL, -- UNIQUE IDENTIFIER FOR THE CONCEPT VERSION
	ConceptId NUMERIC(15) NOT NULL, -- THE CONCEPT TO WHICH THE VERSION APPLIES
	CreationTime DATETIMEOFFSET NOT NULL DEFAULT CURRENT_TIMESTAMP, -- THE CREATION TIME OF THE CONCEPT VERSION
	CreatedBy UNIQUEIDENTIFIER NOT NULL, -- THE USER WHO CREATED THE VERSION
	ObsoletionTime DATETIMEOFFSET, -- THE TIME WHEN THE CONCEPT VERSION IS OBSOLETE
	ObsoletedBy UNIQUEIDENTIFIER, -- THE USER WHO OBSOLETED THE DATA
	ReplacesVersionId NUMERIC(15), -- IDENTIFIES THE VERSION OF THAT THE CURRENT TUPLE REPLACES
	ConceptClassId NUMERIC(2), -- THE CLASSIFICATION OF THE CONCEPT AT THE VERSION
	CONSTRAINT PK_ConceptVersion PRIMARY KEY (ConceptVersionId),
	CONSTRAINT FK_ConceptVersionConcept FOREIGN KEY (ConceptId) REFERENCES Concept(ConceptId),
	CONSTRAINT FK_ConceptVersionCreatedBy FOREIGN KEY (CreatedBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT FK_ConceptVersionObsoletedBy FOREIGN KEY (ObsoletedBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT FK_ConceptVersionConceptClass FOREIGN KEY (ConceptClassId) REFERENCES ConceptClass(ConceptClassId),
	CONSTRAINT CK_ConceptVersionObsoletedBy CHECK(ObsoletedBy IS NOT NULL AND ObsoletionTime IS NOT NULL OR ObsoletedBy IS NULL AND ObsoletionTime IS NULL)
);

-- INDEX: LOOKUP CONCEPT VERSION BY CONCEPT IDENTIFIER
CREATE INDEX IX_ConceptVersionConceptId ON ConceptVersion(ConceptId);
CREATE INDEX IX_ConceptVersionClassId ON ConceptVersion(ConceptClassId);

/*
 THE CONCEPT NAME LOCALIZATION TABLE IS USED TO PROVIDE A LOCALIZED CONCEPT NAME FOR OPENIZ 
 CONCEPTS. THIS REPRESENTS THE CANONICAL NAME OF THE CONCEPT RATHER THAN THE STANDARD WIRELEVEL
 NAME AS FOUND IN ReferenceTermDisplayName
*/
CREATE TABLE ConceptName
(
	ConceptNameId NUMERIC(15) IDENTITY NOT NULL, -- UNIQUE IDENTIFIER FOR THE CONCEPT NAME ID
	EffectiveVersionId NUMERIC(15) NOT NULL, -- THE ID OF THE VERSION WHERE THIS CONCEPT NAME DID BECOME ACTIVE
	ObsoleteVersionId NUMERIC(15), -- THE ID OF THE VERSION WHERE THIS CONCEPT NAME IS NO LONGER ACTIVE
	LanguageCode NVARCHAR(2) NOT NULL, -- THE LANGUAGE CODE OF THE NAME
	Name NVARCHAR(256) NOT NULL, -- THE NAME OF THE CODE
	PhoneticCode NVARCHAR(32) NOT NULL, -- THE PHONETIC CODE FOR THE CONCEPT NAME
	PhoneticAlgorithmId NUMERIC(2) NOT NULL, -- THE PHONETIC ALGORITHM USED TO GENERATE THE CODE
	CONSTRAINT PK_ConceptName PRIMARY KEY (ConceptNameId),
	CONSTRAINT FK_ConceptNameEffectiveVersionId FOREIGN KEY (EffectiveVersionId) REFERENCES ConceptVersion(ConceptVersionId),
	CONSTRAINT FK_ConceptNameObsoleteVersionId FOREIGN KEY (ObsoleteVersionId) REFERENCES ConceptVersion(ConceptVersionId),
	CONSTRAINT FK_ConceptNamePhoneticAlgorithmId FOREIGN KEY (PhoneticAlgorithmId) REFERENCES PhoneticAlgorithm(PhoneticAlgorithmId)
);

-- INDEX TO LOOKUP CONCEPT NAME BY EFFECTIVE VERSION RANGE
CREATE INDEX IX_ConceptNameVersion ON ConceptName(EffectiveVersionId, ObsoleteVersionId);
-- LOOKUP CONCEPT NAME BY NAME
CREATE INDEX IX_ConceptNameName ON ConceptName(Name);
-- LOOKUP CONCEPT NAME BY PHONETIC MATCH
CREATE INDEX IX_ConceptNamePhoneticCode ON ConceptName(PhoneticCode, PhoneticAlgorithmId);

/*
 REPRESENTS THE EXTERNAL CODE SYSTEMS FROM WHICH WIRE-LEVEL CODES CAN BE SENT/RECEIVED
 BY THE OPENIZ BACKBONE. A WIRE-LEVEL CODE IS DIFFERENT THAN A CONCEPT IN THAT MANY
 WIRELEVEL CODES CAN BE USED TO REPRESENT THE SAME CONCEPT. THIS IS THE PIMARY WAY
 THAT WIRE CODES ARE TRANSLATED BETWEEN CODE SYSTEMS AND/OR MESSAGING FORMATS.
*/
CREATE TABLE CodeSystem
(
	CodeSystemId NUMERIC(5) IDENTITY NOT NULL, -- THE UNIQUE IDENTIFIER FOR THE CODE SYSTEM
	Name NVARCHAR(256) NOT NULL, -- HUMAN READABLE NAME FOR THE CODE SYSTEM
	Oid NVARCHAR(64) NOT NULL, -- THE OID OF THE CODE SYSTEM
	Authority NVARCHAR(50), -- THE ASSIGNING AUTHORITY OR ORGANIZATION
	CreationTime DATETIMEOFFSET NOT NULL DEFAULT CURRENT_TIMESTAMP, -- THE CREATIONTIME OF THE CODE SYSTEM
	CreatedBy UNIQUEIDENTIFIER NOT NULL, -- THE USER WHICH CREATED THIS CODE SYSTEM
	ObsoletionTime DATETIMEOFFSET, -- WHEN PRESENT THE TIME THE RECORD WAS OBSOLETED
	ObsoletedBy UNIQUEIDENTIFIER, -- WHEN PRESENT INDICATES THE PERSON WHO OBSOLETED RECORD
	ObsoletionReason NVARCHAR(MAX) , -- WHEN PRESENT INDICATES WHY THE RECORD WAS OBSOLETED
	Url NVARCHAR(256) NOT NULL, -- THE URL OR URI TO THE CODE SYSTEM
	VersionText NVARCHAR(10) NOT NULL, -- THE VERSION OF THE CODE SYSTEM
	CONSTRAINT PK_CodeSystem PRIMARY KEY (CodeSystemId),
	CONSTRAINT FK_CodeSystemCreatedBy FOREIGN KEY (CreatedBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT FK_CodeSystemObsoletedBy FOREIGN KEY (ObsoletedBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT CK_CodeSystemObsoletedBy CHECK(ObsoletedBy IS NOT NULL AND ObsoletionTime IS NOT NULL OR ObsoletedBy IS NULL AND ObsoletionTime IS NULL),
	CONSTRAINT CK_CodeSystemObsoletionReason CHECK(ObsoletionReason IS NOT NULL AND ObsoletionTime IS NOT NULL OR ObsoletionTime IS NULL AND ObsoletionReason IS NULL)
);

-- INDEX: LOOKUP CODE SYSTEM BY OID
CREATE UNIQUE INDEX IX_CodeSystemOid ON CodeSystem(Oid);
-- INDEX: LOOKUP CODE SYSTEM BY URL
CREATE INDEX IX_CodeSystemUrl ON CodeSystem(Url);

CREATE TABLE ConceptRelationshipType
(
	ConceptRelationshipTypeId NUMERIC(2) IDENTITY NOT NULL, -- THE UNIQUE IDENTIFIER OF THE RELATIONSHIP
	Name NVARCHAR(50) NOT NULL, -- THE NAME OF THE RELATIONSHIP TYPE
	Mnemonic NVARCHAR(20) NOT NULL UNIQUE, -- THE UNCHANGING MNEMONIC OF THE RELATIONSHIP TYPE
	CONSTRAINT PK_ConceptRelationshipType PRIMARY KEY (ConceptRelationshipTypeId)
);

CREATE INDEX IX_ConceptRelationshipTypeMnemonic ON ConceptRelationshipType(Mnemonic);

INSERT INTO ConceptRelationshipType (Name, Mnemonic) VALUES ('Same as', 'SameAs');
INSERT INTO ConceptRelationshipType (Name, Mnemonic) VALUES ('Inverse of', 'InverseOf');
INSERT INTO ConceptRelationshipType (Name, Mnemonic) VALUES ('Member of', 'MemberOf');
INSERT INTO ConceptRelationshipType (Name, Mnemonic) VALUES ('Negation of', 'NegationOf');

CREATE TABLE ReferenceTerm
(
	ReferenceTermId NUMERIC(15) IDENTITY NOT NULL, -- THE UNIQUE IDENTIFIER FOR THE REFERENCE TERM
	CodeSystemId NUMERIC(5) NOT NULL, -- THE CODE SYSTEM TO WHICH THE REFERENCE TERM BELONGS
	Mnemonic NVARCHAR(50) NOT NULL, -- THE MNEMONIC
	CONSTRAINT PK_ReferenceTerm PRIMARY KEY (ReferenceTermId),
	CONSTRAINT FK_ReferenceTermCodeSystemId FOREIGN KEY (CodeSystemId) REFERENCES CodeSystem(CodeSystemId)
);

CREATE INDEX IX_ReferenceTermMnemonic ON ReferenceTerm(Mnemonic);
CREATE INDEX IX_ReferenceTermCodeSystemMnemonic ON ReferenceTerm(CodeSystemId, Mnemonic);

CREATE TABLE ConceptReferenceTerm
(
	ConceptReferenceTermId NUMERIC(15) IDENTITY NOT NULL, -- THE UNIQUE IDENTIFIER OF THE REFERENCE TERM LINK
	ReferenceTermId  NUMERIC(15) NOT NULL, -- THE REFERENCE TERM
	EffectiveVersionId NUMERIC(15) NOT NULL, -- THE EFFECTIVE VERSION OF THE REFERENCE TERM
	ObsoleteVersionId NUMERIC(15) NOT NULL, -- THE OBSOLETION VERSION OF THE REFERENCE TERM
	ConceptRelationshipTypeId NUMERIC(2) NOT NULL, -- THE TYPE OF RELATIONSHIP,
	CONSTRAINT PK_ConceptReferenceTerm PRIMARY KEY (ConceptReferenceTermId),
	CONSTRAINT FK_ConceptReferenceTermReferenceTermId FOREIGN KEY (ReferenceTermId) REFERENCES ReferenceTerm(ReferenceTermId),
	CONSTRAINT FK_ConceptReferenceTermEffectiveVersionId FOREIGN KEY (EffectiveVersionId) REFERENCES ConceptVersion(ConceptVersionId),
	CONSTRAINT FK_ConceptReferenceTermObsoleteVersionId FOREIGN KEY (ObsoleteVersionId) REFERENCES ConceptVersion(ConceptVersionId),
	CONSTRAINT FK_ConceptReferenceTermConceptRelationshipTypeId FOREIGN KEY (ConceptRelationshipTypeId) REFERENCES ConceptRelationshipType(ConceptRelationshipTypeId)
);

CREATE TABLE ReferenceTermDisplayName
(
	ReferenceTermDisplayNameId NUMERIC(15) IDENTITY NOT NULL, -- UNIQUE IDENTIFIER OF THE REFERENCE TERM LINK
	ReferenceTermId NUMERIC(15) NOT NULL, -- UNIQUE IDENTIFIER OF THE REFERENCE TERM
	LanguageCode NVARCHAR(2) NOT NULL, -- LANGUAGE IN WHICH THE REFERENCE TERM IS REPRESENTED
	DisplayName NVARCHAR(256) NOT NULL, -- THE DISPLAY NAME 
	CreationTime DATETIMEOFFSET NOT NULL DEFAULT CURRENT_TIMESTAMP, -- THE CREATION TIME
	CreatedBy UNIQUEIDENTIFIER NOT NULL, -- THE USER THAT CREATED THE DISPLAY NAME
	ObsoletionTime DATETIMEOFFSET, -- WHEN PRESENT REPRESENTS THE TIME THE RECORD WAS OBSOLETE
	ObsoletedBy UNIQUEIDENTIFIER, -- THE USER WHO OBSOLETED THIS RECORD
	ObsoletionReason NVARCHAR(MAX), -- WHEN PRESENT INDICATES WHY THE RECORD WAS OBSOLETED
	PhoneticCode NVARCHAR(20) NOT NULL, -- THE PHONETIC CODE 
	PhoneticAlgorithmId NUMERIC(2) NOT NULL, -- THE ALGORITHM USED TO GENERATE THE CODE
	CONSTRAINT PK_ReferenceTermDisplayName PRIMARY KEY (ReferenceTermDisplayNameId),
	CONSTRAINT FK_ReferenceTermDisplayNameReferenceTermId FOREIGN KEY (ReferenceTermId) REFERENCES ReferenceTerm(ReferenceTermId),
	CONSTRAINT FK_ReferenceTermCreatedBy FOREIGN KEY (CreatedBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT FK_ReferenceTermObsoletedBy FOREIGN KEY (ObsoletedBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT FK_ReferenceTermPhoneticAlgorithmId FOREIGN KEY (PhoneticAlgorithmId) REFERENCES PhoneticAlgorithm(PhoneticAlgorithmId),
	CONSTRAINT CK_ReferenceTermObsoletedBy CHECK(ObsoletedBy IS NOT NULL AND ObsoletionTime IS NOT NULL OR ObsoletedBy IS NULL AND ObsoletionTime IS NULL),
	CONSTRAINT CK_ReferenceTermObsoletionReason  CHECK(ObsoletionReason IS NOT NULL AND ObsoletionTime IS NOT NULL OR ObsoletionTime IS NULL AND ObsoletionReason IS NULL)
);

CREATE INDEX IX_ReferenceTermDisplayNamePhonetic ON ReferenceTermDisplayName(PhoneticCode, PhoneticAlgorithmId);
CREATE INDEX IX_ReferenceTermDisplayNameName ON ReferenceTermDisplayName(DisplayName);

CREATE TABLE ConceptRelationship
(
	ConceptRelationshipId NUMERIC(15) IDENTITY NOT NULL, -- THE UNIQUE IDENTIFIER FOR THE CONCEPT RELATIONSHIP
	SourceConceptId NUMERIC(15) NOT NULL, -- THE SOURCE OF THE CONCEPT RELATIONSHIP
	TargetConceptId NUMERIC(15) NOT NULL, -- THE TARGET OF THE RELATIONSHIP
	ConceptRelationshipTypeId NUMERIC(2) NOT NULL, -- THE TYPE OF RELATIONSHIP
	EffectiveVersionId NUMERIC(15) NOT NULL, -- THE VERSION OF THE CONCEPT TO WHICH THE SOURCE RELATION APPLIES
	ObsoleteVersionId NUMERIC(15) NOT NULL, -- THE VERSION OF THE CONCEPT WHEN THE RELATION IS NO LONGER VALID
	CONSTRAINT PK_ConceptRelationship PRIMARY KEY (ConceptRelationshipId),
	CONSTRAINT FK_ConceptRelationshipSourceConceptId FOREIGN KEY (SourceConceptId) REFERENCES Concept(ConceptId),
	CONSTRAINT FK_ConceptRelationshipTargetConceptId FOREIGN KEY (TargetConceptId) REFERENCES Concept(ConceptId),
	CONSTRAINT FK_ConceptRelationshipConceptRelationshipTypeId FOREIGN KEY (ConceptRelationshipTypeId) REFERENCES ConceptRelationshipType(ConceptRelationshipTypeId),
	CONSTRAINT FK_ConceptRelationshipEffectiveVersionId FOREIGN KEY (EffectiveVersionId) REFERENCES ConceptVersion(ConceptVersionId),
	CONSTRAINT FK_ConceptRelationshpObsoleteVersionId FOREIGN KEY (ObsoleteVersionId) REFERENCES ConceptVersion(ConceptVersionId)
);

CREATE INDEX IX_ConceptRelationshipSource ON ConceptRelationship(SourceConceptId);
CREATE INDEX IX_ConceptRelationshipTarget ON ConceptRelationship(TargetConceptId);

GO 

CREATE VIEW ConceptCurrentVersion AS
	SELECT ConceptVersion.*, Concept.IsSystemConcept, ConceptClass.Mnemonic AS ConceptClassMnemonic FROM ConceptVersion INNER JOIN Concept ON (ConceptVersion.ConceptId = Concept.ConceptId)
		INNER JOIN ConceptClass ON (ConceptVersion.ConceptClassId = ConceptClass.ConceptClassId)
		WHERE ConceptVersion.ObsoletionTime IS NULL;
GO

CREATE FUNCTION fn_AssertConceptClass (@ConceptId NUMERIC, @AssertClassMnemonic NVARCHAR)
RETURNS BIT BEGIN
	RETURN (SELECT COUNT(*) FROM ConceptCurrentVersion WHERE ConceptId = @ConceptId AND ConceptClassMnemonic = @AssertClassMnemonic);
END;

GO

CREATE FUNCTION fn_IsConceptSetMember (@ConceptId NUMERIC, @ConceptSetMnemonic NVARCHAR)
RETURNS BIT BEGIN
	RETURN (SELECT COUNT(*) FROM ConceptSetMember INNER JOIN ConceptSet ON (ConceptSetMember.ConceptSetId = ConceptSet.ConceptSetId)
		WHERE ConceptSet.Mnemonic = @ConceptSetMnemonic AND ConceptId = @ConceptId);
END;

GO

CREATE TABLE ExtensionType
(
	ExtensionTypeId UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID(), -- THE UNIQUE IDENTIFIER FOR THE EXTENSION
	HandlerClass NVARCHAR(256) NOT NULL, -- THE IEXTENSIONHANDLER WHICH CAN SERIALIZE/DESERIALIZE AND VALIDATE THE EXTENSION
	Name NVARCHAR(64) NOT NULL, -- THE HUMAN NAME FOR THE EXTENSION
	IsEnabled BIT NOT NULL DEFAULT 0, -- INDICATES WHETHER THE EXTENSION IS ENABLED
	CreationTime DATETIMEOFFSET NOT NULL DEFAULT CURRENT_TIMESTAMP, -- THE TIME THE EXTENSION WAS CREATE
	EnabledBy UNIQUEIDENTIFIER NOT NULL, -- THE USER THAT CREATED THE EXTENSION, OR IF IT WAS INSTALLED, THE USER THAT INSTALLED THE EXTENSION
	UpdateTime DATETIMEOFFSET, -- THE TIME THE EXTENSION WAS UPDATED
	UpdatedBy UNIQUEIDENTIFIER, -- THE PERSON WHO LAST UPDATED THE EXTENSION
	ObsoletionTime DATETIMEOFFSET, -- THE TIME THE EXTENSION WAS OBSOLETED
	ObsoletedBy UNIQUEIDENTIFIER, -- THE PERSON WHO OBSOLETED THE EXTENSION
	CONSTRAINT PK_ExtensionType PRIMARY KEY (ExtensionTypeId),
	CONSTRAINT FK_ExtensionTypeEnabledBy FOREIGN KEY (EnabledBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT FK_ExtensionTypeUpdatedBy FOREIGN KEY (UpdatedBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT FK_ExtensionTypeObsoletedBy FOREIGN KEY (ObsoletedBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT CK_ExtensionTypeObsoletedBy CHECK(ObsoletedBy IS NOT NULL AND ObsoletionTime IS NOT NULL OR ObsoletedBy IS NULL AND ObsoletionTime IS NULL),
	CONSTRAINT CK_ExtensionTypeUpdatedBy CHECK(UpdatedBy IS NOT NULL AND UpdateTime IS NOT NULL OR UpdatedBy IS NULL AND UpdateTime IS NULL)
);

CREATE TABLE PhoneticAlgorithmType
(
	PhoneticAlgorithmId UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID(), -- THE UNIQUE IDENTIFIER FOR THE PHONETIC ALGORITHM
	Name NVARCHAR(64) NOT NULL, -- THE HUMAN NAME OF THE PHONETIC ALGORITHM
	HandlerClass NVARCHAR(256) NOT NULL, -- THE CLASS OF TYPE IPHONETICALGORITHM WHICH GENERATES PHONETIC CODES
	CONSTRAINT PK_PhoneticAlgorithmType PRIMARY KEY (PhoneticAlgorithmId)
);

CREATE TABLE PhoneticValues
(
	PhoneticValueId UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID(), -- THE UNIQUE IDENTIFIER FOR THE PHONETIC CODE
	Value NVARCHAR(64) NOT NULL, -- THE VALUE OF THE PHONETIC VALUE IN HUMAN READABLE FORM
	PhoneticCode NVARCHAR(32) NOT NULL, -- THE PHONETIC CODE OF THE VALUE
	PhoneticAlgorithmId UNIQUEIDENTIFIER NOT NULL, -- THE PHONETIC ALGORITHM USED TO GENERATE THE PHONETIC CODE
	CONSTRAINT PK_PhoneticValues PRIMARY KEY (PhoneticValueId),
	CONSTRAINT FK_PhoneticValuesPhoneticAlgorithmId FOREIGN KEY (PhoneticAlgorithmId) REFERENCES PhoneticAlgorithmType(PhoneticAlgorithmId)
);

CREATE INDEX IX_PhoneticValuesPhoneticCode ON PhoneticValues(PhoneticCode, PhoneticAlgorithmId);

CREATE TABLE EntityNameUse
(
	EntityNameUseId UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID(), -- THE UNIQUE IDENTIFIER FOR THE USE
	NameUseConceptId NUMERIC(15) NOT NULL, -- THE USE CONCEPT CODE
	EntityClassScopeConceptId NUMERIC(15) NOT NULL, -- ENTITY CLASS WHICH THE USE CAN BE USED ON A NAME
	CONSTRAINT PK_EntityNameUse PRIMARY KEY (EntityNameUseId),
	CONSTRAINT FK_EntityNameUseNameUseConceptId FOREIGN KEY (NameUseConceptId) REFERENCES Concept(ConceptId),
	CONSTRAINT FK_EntityNameUseEntityClassScopeConceptId FOREIGN KEY (EntityClassScopeConceptId) REFERENCES Concept(ConceptId)
);

CREATE TABLE EntityIdentifierType
(
	EntityIdentifierTypeId UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID(), -- THE UNIQUE IDENTIFIER FOR THE IDENTITIFER TYPE
	IdentifierTypeConceptId NUMERIC(15) NOT NULL, -- THE CONCEPT WHICH REPRESENTS THE TYPE
	EntityClassScopeConceptId NUMERIC(15) NOT NULL, -- THE SCOPE IN WHICH THE ENTITY IDENTIFIER TYPE CAN BE USED
	CONSTRAINT PK_EntityIdentifierType PRIMARY KEY (EntityIdentifierTypeId),
	CONSTRAINT FK_EntityIdentifierTypeIdentifierTypeConceptId FOREIGN KEY (IdentifierTypeConceptId) REFERENCES Concept(ConceptId),
	CONSTRAINT FK_EntityIdentifierTypeEntityClassScopeConceptId FOREIGN KEY (EntityClassScopeConceptId) REFERENCES Concept(ConceptId)
);

CREATE TABLE Act
(
	ActId NUMERIC(15) IDENTITY NOT NULL, -- THE UNIQUE IDENTIFIER FOR THE ACT. THIS IS A NUMERIC FOR EASE OF
	ClassConceptId NUMERIC(15) NOT NULL, -- CLASSIFIES THE TYPE OF ACT REPRESENTED
	CONSTRAINT PK_Act PRIMARY KEY (ActId),
	CONSTRAINT FK_ActClassConceptId FOREIGN KEY (ClassConceptId) REFERENCES Concept(ConceptId),
	CONSTRAINT CK_ActClassConceptIdConceptClass CHECK (dbo.fn_AssertConceptClass(ClassConceptId, 'ActClass') = 1)
);

CREATE TABLE ActVersion
(
	ActVersionId NUMERIC(15) IDENTITY NOT NULL, -- THE UNIQUE IDENTIFIER FOR THE VERSION
	ActId NUMERIC(15) NOT NULL, -- THE ACT TO WHICH THE VERSION APPLIES
	CreationTime DATETIMEOFFSET NOT NULL DEFAULT CURRENT_TIMESTAMP, -- THE CREATION TIME OF THE ACT
	CreatedBy UNIQUEIDENTIFIER NOT NULL, -- THE POINTER TO THE USER WHO CREATED THE VERSION
	ObsoletionTime DATETIMEOFFSET, -- THE TIME WHEN THE ACT IS OBSOLETED
	ObsoletedBy UNIQUEIDENTIFIER, -- THE USER WHO OBSOLETED THE RECORD
	ObsoletionReason NVARCHAR(MAX), -- A REASON FOR OBSOLETION
	ReplacesVersionId NUMERIC(15), -- THE VERSION REPLACED BY THIS ACT VERSION
	NegationInd BIT NOT NULL DEFAULT 0, -- AN INDICATOR WHICH DESCRIBES THE ACT DID NOT 
	TypeConceptId NUMERIC(15) NOT NULL, -- THE TYPE OF ACT CLASSIFIER (I.E. THE TYPE OF OBSERVATION, THE TYPE OF PROBLEM, ETC.)
	StatusConceptId NUMERIC(15) NOT NULL, -- THE CURRENT STATUS OF THE ACT
	ActStartTime DATETIMEOFFSET, -- THE TIME WHEN THE ACT STARTED
	ActStopTime DATETIMEOFFSET, -- THE TIME WHEN THE ACT STOPPED
	MoodConceptId NUMERIC(15) NOT NULL, -- THE MOOD OF THE ACT
	CONSTRAINT PK_ActVersion PRIMARY KEY (ActVersionId),
	CONSTRAINT FK_ActVersionAct FOREIGN KEY (ActId) REFERENCES Act(ActId),
	CONSTRAINT FK_ActVersionCreatedBy FOREIGN KEY (CreatedBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT FK_ActVersionObsoletedBy FOREIGN KEY (ObsoletedBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT FK_ActVersionReplacesVersionId FOREIGN KEY (ReplacesVersionId) REFERENCES ActVersion(ActVersionId),
	CONSTRAINT FK_ActVersionTypeConceptId FOREIGN KEY (TypeConceptId) REFERENCES Concept(ConceptId),
	CONSTRAINT FK_ActVersionStatusConceptId FOREIGN KEY (StatusConceptId) REFERENCES Concept(ConceptId),
	CONSTRAINT FK_ActVersionMoodConceptId FOREIGN KEY (MoodConceptId) REFERENCES Concept(ConceptId),
	CONSTRAINT CK_ActVersionActClassStatusConceptIdConceptClass CHECK (dbo.fn_AssertConceptClass(StatusConceptId, 'ActStatus') = 1),
	CONSTRAINT CK_ActVersionActMoodConceptIdConceptClass CHECK (dbo.fn_AssertConceptClass(MoodConceptId, 'ActMood') = 1),
	CONSTRAINT CK_ActVersionObsoletedBy CHECK(ObsoletedBy IS NOT NULL AND ObsoletionTime IS NOT NULL OR ObsoletedBy IS NULL AND ObsoletionTime IS NULL)
);

CREATE TABLE ActRelationship
(
	ActRelationshipId UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID(), -- UNIQUE IDENTIFIER FOR THE RELATIONSHIP, ID IS A GUID BECAUSE IT ISN'T PUBLIC FACING
	SourceActId NUMERIC(15) NOT NULL, -- THE SOURCE ACT
	TargetActId NUMERIC(15) NOT NULL, -- THE TARGET ACT
	EffectiveVersionId NUMERIC(15) NOT NULL, -- THE EFFECTIVE VERSION OF THE ACT WHERE THE ASSOCIATION IS ACTIVE
	ObsoleteVersionId NUMERIC(15) NOT NULL, -- THE OBSOLETION VERSION OF THE ACT
	RelationshipTypeConceptId NUMERIC(15) NOT NULL, -- THE RELATIONSHIP OF THE ACT
	CONSTRAINT PK_ActRelationship PRIMARY KEY (ActRelationshipId),
	CONSTRAINT FK_ActRelationshipSourceActId FOREIGN KEY (SourceActId) REFERENCES Act(ActId),
	CONSTRAINT FK_ActRelationshipTargetActId FOREIGN KEY (TargetActId) REFERENCES Act(ActId),
	CONSTRAINT FK_ActRelationshipEffectiveVersionId FOREIGN KEY (EffectiveVersionId) REFERENCES ActVersion(ActVersionId),
	CONSTRAINT FK_ActRelationshipObsoleteVersionId FOREIGN KEY (ObsoleteVersionId) REFERENCES ActVersion(ActVersionId),
	CONSTRAINT FK_ActRelationshipRelationshipTypeConceptId FOREIGN KEY (RelationshipTypeConceptId) REFERENCES Concept(ConceptId),
	CONSTRAINT CK_ActRelationshipRelationshipTypeConceptConceptClass CHECK (dbo.fn_AssertConceptClass(RelationshipTypeConceptId, 'ActRelationship') = 1)
);

CREATE TABLE ActExtension
(
	ActExtensionId UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID(), -- UNIQUE IDENTIFIER FOR THE EXTENSION INSTANCE
	ExtensionTypeId UNIQUEIDENTIFIER NOT NULL, -- THE TYPE OF EXTENSION
	ExtensionValue VARBINARY(MAX), -- THE SERIALIZED EXTENSION VALUE
	ExtensionDisplay NVARCHAR(64), -- A DISPLAY VERSION OF THE EXTENSION VALUE
	EffectiveVersionId NUMERIC(15) NOT NULL, -- THE VERSION WHERE THE EXTENSION BECOMES ACTIVE
	ObsoleteVersionId NUMERIC(15), -- THE VERSION WHERE THE EXTENSION IS NO LONGER VALID
	CONSTRAINT PK_ActExtension PRIMARY KEY (ActExtensionId),
	CONSTRAINT FK_ActExtensionExtensionTypeId FOREIGN KEY (ExtensionTypeId) REFERENCES ExtensionType(ExtensionTypeId),
	CONSTRAINT FK_ActExtensionEffectiveVersionId FOREIGN KEY (EffectiveVersionId) REFERENCES ActVersion(ActVersionId),
	CONSTRAINT FK_ActExtensionObsoleteVersionId FOREIGN KEY (ObsoleteVersionId) REFERENCES ActVersion(ActVersionId)
);

CREATE TABLE Observation
(
	ActVersionId NUMERIC(15) NOT NULL, -- THE VERSION TO WHICH THIS OBSERVATION DATA APPLIES
	InterpretationConceptId NUMERIC(15) NOT NULL, -- THE INTERPRETAION CODE
	CONSTRAINT PK_Observation PRIMARY KEY (ActVersionId),
	CONSTRAINT FK_ObservationActVersionId FOREIGN KEY (ActVersionId) REFERENCES ActVersion(ActVersionId),
	CONSTRAINT FK_ObservationInterpretationConceptId FOREIGN KEY (InterpretationConceptId) REFERENCES Concept(ConceptId),
	CONSTRAINT CK_ObservationInterpretationConceptClass CHECK (dbo.fn_AssertConceptClass(InterpretationConceptId, 'ActInterpretation') = 1)
);

CREATE TABLE QuantityObservation
(
	ActVersionId NUMERIC(15) NOT NULL, -- THE VERSION TO WHICH THE OBSERVATION QUANTITY APPLIES
	Quantity DECIMAL NOT NULL, -- THE QUANTITY OF THE OBSERVATION
	QuantityPrecision NUMERIC(2) NOT NULL, -- IDENTIFIES THE PRECISION OF THE OBSERVED VALUE
	UnitOfMeasureConceptId NUMERIC(15) NOT NULL, -- IDENTIFIES THE UNIT OF MEASURE CONCEPT
	CONSTRAINT PK_QuantityObservation PRIMARY KEY (ActVersionId),
	CONSTRAINT FK_QuantityObservationActVersionId FOREIGN KEY (ActVersionId) REFERENCES Observation(ActVersionId),
	CONSTRAINT FK_QuantityObservationUnitOfMeasureConceptId FOREIGN KEY (UnitOfMeasureConceptId) REFERENCES	Concept(ConceptId),
	CONSTRAINT CK_QuantityObservationUnitOfMeasureConceptClass CHECK (dbo.fn_AssertConceptClass(UnitOfMeasureConceptId, 'UnitOfMeasure') = 1)
);

CREATE TABLE CodedObservation
(
	ActVersionId NUMERIC(15) NOT NULL, -- THE VERSION OF THE OBSERVATION THIS CODED VALUE CORRESPONDS TO
	ValueConceptId NUMERIC(15) NOT NULL, -- THE VALUE OF THE CODE
	CONSTRAINT PK_CodedObservation PRIMARY KEY (ActVersionId),
	CONSTRAINT FK_CodedObservationActVersionId FOREIGN KEY (ActVersionId) REFERENCES Observation(ActVersionId),
	CONSTRAINT FK_CodedObservationValueConceptId FOREIGN KEY (ValueConceptId) REFERENCES Concept(ConceptId)
);

CREATE TABLE TextObservation
(
	ActVersionId NUMERIC(15) NOT NULL, -- THE VERSION OF THE OBSERVATION THIS STRING VALUE CORRESPONDS TO
	Value VARCHAR(MAX) NOT NULL, -- THE VALUE OF THE OBSERVATION
	CONSTRAINT PK_StringObservation PRIMARY KEY (ActVersionId),
	CONSTRAINT FK_StringObservationActVersionId FOREIGN KEY (ActVersionId) REFERENCES Observation(ActVersionId),
);

CREATE TABLE PatientEncounter
(
	ActVersionId NUMERIC(15) NOT NULL, -- THE ACT IDENTIFIER TO WHICH THIS PATIENT ENCOUNTER DATA BELONGS
	DischargeDispositionConceptId NUMERIC(15), -- THE MANNER IN WHICH THE PATIENT LEFT THE ENCOUNTER
	CONSTRAINT PK_PatientEncounter PRIMARY KEY (ActVersionId),
	CONSTRAINT FK_PatientEncounterActVersionId FOREIGN KEY (ActVersionId) REFERENCES ActVersion(ActVersionId),
	CONSTRAINT FK_PatientEncounterDischargeDispositionConceptId FOREIGN KEY (DischargeDispositionConceptId) REFERENCES Concept(ConceptId)
);

CREATE TABLE SubstanceAdministration
(
	ActVersionId NUMERIC(15) NOT NULL, -- THE ACT IDENTIFIER TO WHICH THIS SUBSTANCE ADMINISTRATION DATA BELONGS
	RouteConceptId NUMERIC(15) NOT NULL, -- THE ROUTE WHICH THE SUBSTANCE WAS ADMINISTERED
	DoseQuantity DECIMAL NOT NULL, -- THE DOSE QUANTITY GIVEN
	DoseUnitConceptId NUMERIC(15) NOT NULL, -- THE UOM FOR THE DOSE
	SequenceId INT NOT NULL, -- THE SEQUENCE OF THE DOSE
	CONSTRAINT PK_SubstanceAdministration PRIMARY KEY (ActVersionId),
	CONSTRAINT FK_SubstanceAdministrationActVersionId FOREIGN KEY (ActVersionId) REFERENCES ActVersion(ActVersionId),
	CONSTRAINT FK_SubstanceAdministrationRouteConceptId FOREIGN KEY (RouteConceptId) REFERENCES Concept(ConceptId),
	CONSTRAINT CK_SubstanceAdministrationRouteConceptClassCode CHECK (dbo.fn_AssertConceptClass(RouteConceptId, 'RouteOfAdminsitration') = 1),
	CONSTRAINT FK_SubstanceAdministrationDoseUnitConceptId FOREIGN KEY (DoseUnitConceptId) REFERENCES Concept(ConceptId),
	CONSTRAINT CK_SubstanceAdministrationDoseUnitConceptClassCode CHECK (dbo.fn_AssertConceptClass(DoseUnitConceptId, 'UnitOfMeasure') = 1)
);

CREATE TABLE ActTag
(
	ActTagId UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID(), -- UNIQUE IDENTIFIER FOR THE TAG
	ActId NUMERIC(15) NOT NULL, -- THE ACT IDENTIFIER
	Name NVARCHAR(64) NOT NULL, -- THE NAME OF THE TAG
	Value NVARCHAR(MAX), -- THE VALUE OF THE TAG
	CreationTime DATETIMEOFFSET NOT NULL DEFAULT CURRENT_TIMESTAMP, -- THE TIME THAT THE TAG WAS ATTACHED
	CreatedBy UNIQUEIDENTIFIER, -- THE USER THAT CREATED THE TAG
	ObsoletionTime DATETIMEOFFSET, -- THE TIME WHEN THE TAG WAS OBSOLETED
	ObsoletedBy UNIQUEIDENTIFIER, -- THE USER WHO OBSOLETED THE TAG
	CONSTRAINT PK_ActTag PRIMARY KEY (ActTagId),
	CONSTRAINT FK_ActTagActId FOREIGN KEY (ActId) REFERENCES Act(ActId),
	CONSTRAINT FK_ActTagCreatedBy FOREIGN KEY (CreatedBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT FK_ActTagObsoletedBy FOREIGN KEY (ObsoletedBy) REFERENCES SecurityUser(UserId),
	CONSTRAINT CK_ActTagObsoletedBy CHECK(ObsoletedBy IS NOT NULL AND ObsoletionTime IS NOT NULL OR ObsoletedBy IS NULL AND ObsoletionTime IS NULL)
);

CREATE TABLE ActPolicy
(
	ActPolicyId UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID(), -- THE UNIQUE IDENTIFIER FOR THE ACT/POLICY 
	EffectiveVersionId NUMERIC(15) NOT NULL, -- THE VERSION FROM WHICH THE POLICY IS EFFECITVE
	ObsoleteVersionId NUMERIC(15), -- THE VERSION AT WHICH THE POLICY NO LONGER APPLIES
	PolicyId UNIQUEIDENTIFIER NOT NULL, -- THE POLICY APPLIED
	CONSTRAINT PK_ActPolicy PRIMARY KEY (ActPolicyId),
	CONSTRAINT FK_ActPolicyEffectiveVersionId FOREIGN KEY (EffectiveVersionId) REFERENCES ActVersion(ActVersionId),
	CONSTRAINT FK_ActPolicyObsoleteVersionId FOREIGN KEY (ObsoleteVersionId) REFERENCES ActVersion(ActVersionId),
	CONSTRAINT FK_ActPolicyPolicyId FOREIGN KEY (PolicyId) REFERENCES Policy(PolicyId)
);
